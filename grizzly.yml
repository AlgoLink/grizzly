postgresql:
  createfunction: CREATE OR REPLACE FUNCTION $$name$$($$inparams$$) RETURNS $$returntype$$ LANGUAGE plpython3u AS '$$code$$' parallel safe;

  applymodelfunction: |
      import random
      import torch

      $$modelclassdef$$

      $$helpers$$
      $$encoder$$
      if not hasattr(random, "model_$$modelpathhash$$"):
        #random.model_$$modelpathhash$$ = torch.load("$$modelpath$$")
        
        random.model_$$modelpathhash$$ = $$modelclassname$$($$modelclassparameters$$)
        random.model_$$modelpathhash$$.load_state_dict(torch.load("$$modelpath$$"))
        
        random.model_$$modelpathhash$$.eval()

        random.outputDict_$$modelpathhash$$ = $$outputdict$$

      model = random.model_$$modelpathhash$$
      hidden = model.initHidden()

      tensor = torch.autograd.Variable($$encoderfuncname$$(invalue))
      for i in range(tensor.size()[0]):
        output, hidden = model(tensor[i], hidden)

      topv, topi = output.data.topk(n_predictions, 1, True)

      #return str(topi[0][i])+" "+str(topv[0][i])
      predictions = []
      for i in range(n_predictions):
        #value = topv[0][i]
        cat_index = topi[0][i]
        out = random.outputDict_$$modelpathhash$$[cat_index]
        predictions.append(str(out))

      return "\n".join(predictions)

vectorh:
  createfunction: CREATE OR REPLACE FUNCTION $$name$$($$inparams$$) RETURN ($$returntype$$) AS LANGUAGE PYTHON SOURCE='$$code$$';